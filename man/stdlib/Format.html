<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Filename.html">
<link rel="next" href="Gc.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Arg" rel="Chapter" href="Arg.html">
<link title="Arith_status" rel="Chapter" href="Arith_status.html">
<link title="Array" rel="Chapter" href="Array.html">
<link title="ArrayLabels" rel="Chapter" href="ArrayLabels.html">
<link title="Big_int" rel="Chapter" href="Big_int.html">
<link title="Bigarray" rel="Chapter" href="Bigarray.html">
<link title="Buffer" rel="Chapter" href="Buffer.html">
<link title="Callback" rel="Chapter" href="Callback.html">
<link title="CamlinternalLazy" rel="Chapter" href="CamlinternalLazy.html">
<link title="CamlinternalMod" rel="Chapter" href="CamlinternalMod.html">
<link title="CamlinternalOO" rel="Chapter" href="CamlinternalOO.html">
<link title="Char" rel="Chapter" href="Char.html">
<link title="Complex" rel="Chapter" href="Complex.html">
<link title="Condition" rel="Chapter" href="Condition.html">
<link title="Dbm" rel="Chapter" href="Dbm.html">
<link title="Digest" rel="Chapter" href="Digest.html">
<link title="Dynlink" rel="Chapter" href="Dynlink.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Filename" rel="Chapter" href="Filename.html">
<link title="Format" rel="Chapter" href="Format.html">
<link title="Gc" rel="Chapter" href="Gc.html">
<link title="Genlex" rel="Chapter" href="Genlex.html">
<link title="Graphics" rel="Chapter" href="Graphics.html">
<link title="GraphicsX11" rel="Chapter" href="GraphicsX11.html">
<link title="Hashtbl" rel="Chapter" href="Hashtbl.html">
<link title="Int32" rel="Chapter" href="Int32.html">
<link title="Int64" rel="Chapter" href="Int64.html">
<link title="Lazy" rel="Chapter" href="Lazy.html">
<link title="Lexing" rel="Chapter" href="Lexing.html">
<link title="List" rel="Chapter" href="List.html">
<link title="ListLabels" rel="Chapter" href="ListLabels.html">
<link title="Map" rel="Chapter" href="Map.html">
<link title="Marshal" rel="Chapter" href="Marshal.html">
<link title="MoreLabels" rel="Chapter" href="MoreLabels.html">
<link title="Mutex" rel="Chapter" href="Mutex.html">
<link title="Nativeint" rel="Chapter" href="Nativeint.html">
<link title="Num" rel="Chapter" href="Num.html">
<link title="Obj" rel="Chapter" href="Obj.html">
<link title="Oo" rel="Chapter" href="Oo.html">
<link title="Parsing" rel="Chapter" href="Parsing.html">
<link title="Pervasives" rel="Chapter" href="Pervasives.html">
<link title="Printexc" rel="Chapter" href="Printexc.html">
<link title="Printf" rel="Chapter" href="Printf.html">
<link title="Queue" rel="Chapter" href="Queue.html">
<link title="Random" rel="Chapter" href="Random.html">
<link title="Scanf" rel="Chapter" href="Scanf.html">
<link title="Set" rel="Chapter" href="Set.html">
<link title="Sort" rel="Chapter" href="Sort.html">
<link title="Stack" rel="Chapter" href="Stack.html">
<link title="StdLabels" rel="Chapter" href="StdLabels.html">
<link title="Str" rel="Chapter" href="Str.html">
<link title="Stream" rel="Chapter" href="Stream.html">
<link title="String" rel="Chapter" href="String.html">
<link title="StringLabels" rel="Chapter" href="StringLabels.html">
<link title="Sys" rel="Chapter" href="Sys.html">
<link title="Thread" rel="Chapter" href="Thread.html">
<link title="ThreadUnix" rel="Chapter" href="ThreadUnix.html">
<link title="Tk" rel="Chapter" href="Tk.html">
<link title="Unix" rel="Chapter" href="Unix.html">
<link title="UnixLabels" rel="Chapter" href="UnixLabels.html">
<link title="Weak" rel="Chapter" href="Weak.html"><link title="Boxes" rel="Section" href="#6_Boxes">
<link title="Formatting functions" rel="Section" href="#6_Formattingfunctions">
<link title="Break hints" rel="Section" href="#6_Breakhints">
<link title="Margin" rel="Section" href="#6_Margin">
<link title="Maximum indentation limit" rel="Section" href="#6_Maximumindentationlimit">
<link title="Formatting depth: maximum number of boxes allowed before ellipsis" rel="Section" href="#6_Formattingdepthmaximumnumberofboxesallowedbeforeellipsis">
<link title="Advanced formatting" rel="Section" href="#6_Advancedformatting">
<link title="Tabulations" rel="Section" href="#6_Tabulations">
<link title="Ellipsis" rel="Section" href="#6_Ellipsis">
<link title="Tags" rel="Section" href="#6_Tags">
<link title="Redirecting formatter output" rel="Section" href="#6_Redirectingformatteroutput">
<link title="Changing the meaning of printing tags" rel="Section" href="#6_Changingthemeaningofprintingtags">
<link title="Changing the meaning of pretty printing (indentation, line breaking,
 and printing material)" rel="Section" href="#6_Changingthemeaningofprettyprintingindentationlinebreakingandprintingmaterial">
<link title="Multiple formatted output" rel="Section" href="#6_Multipleformattedoutput">
<link title="Basic functions to use with formatters" rel="Section" href="#6_Basicfunctionstousewithformatters">
<link title="printf like functions for pretty-printing." rel="Section" href="#6_printflikefunctionsforprettyprinting">
<title>Format</title>
</head>
<body>
<div class="navbar"><a href="Filename.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Gc.html">Next</a>
</div>
<center><h1>Module <a href="type_Format.html">Format</a></h1></center>
<br>
<pre><span class="keyword">module</span> Format: <code class="code"><span class="keyword">sig</span></code> <a href="Format.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>Pretty printing.
<p>

   This module implements a pretty-printing facility to format text
   within ``pretty-printing boxes''. The pretty-printer breaks lines
   at specified break hints, and indents lines according to the box
   structure.
<p>

   For a gentle introduction to the basics of pretty-printing using
   <code class="code"><span class="constructor">Format</span></code>, read
   <a href="http://caml.inria.fr/resources/doc/guides/format.html">http://caml.inria.fr/resources/doc/guides/format.html</a>.
<p>

   You may consider this module as providing an extension to the
   <code class="code">printf</code> facility to provide automatic line breaking. The addition of
   pretty-printing annotations to your regular <code class="code">printf</code> formats gives you
   fancy indentation and line breaks.
   Pretty-printing annotations are described below in the documentation of
   the function <a href="Format.html#VALfprintf"><code class="code"><span class="constructor">Format</span>.fprintf</code></a>.
<p>

   You may also use the explicit box management and printing functions
   provided by this module. This style is more basic but more verbose
   than the <code class="code">fprintf</code> concise formats.
<p>

   For instance, the sequence
   <code class="code">open_box 0; print_string <span class="string">"x ="</span>; print_space (); print_int 1; close_box ()</code>
   that prints <code class="code">x = 1</code> within a pretty-printing box, can be
   abbreviated as <code class="code">printf <span class="string">"@[%s@ %i@]"</span> <span class="string">"x ="</span> 1</code>, or even shorter
   <code class="code">printf <span class="string">"@[x =@ %i@]"</span> 1</code>.
<p>

   Rule of thumb for casual users of this library:<ul>
<li>use simple boxes (as obtained by <code class="code">open_box 0</code>);</li>
<li>use simple break hints (as obtained by <code class="code">print_cut ()</code> that outputs a
   simple break hint, or by <code class="code">print_space ()</code> that outputs a space
   indicating a break hint);</li>
<li>once a box is opened, display its material with basic printing
   functions (e. g. <code class="code">print_int</code> and <code class="code">print_string</code>);</li>
<li>when the material for a box has been printed, call <code class="code">close_box ()</code> to
   close the box;</li>
<li>at the end of your routine, evaluate <code class="code">print_newline ()</code> to close
   all remaining boxes and flush the pretty-printer.</li>
</ul>

   The behaviour of pretty-printing commands is unspecified
   if there is no opened pretty-printing box. Each box opened via
   one of the <code class="code">open_</code> functions below must be closed using <code class="code">close_box</code>
   for proper formatting. Otherwise, some of the material printed in the
   boxes may not be output, or may be formatted incorrectly.
<p>

   In case of interactive use, the system closes all opened boxes and
   flushes all pending text (as with the <code class="code">print_newline</code> function)
   after each phrase. Each phrase is therefore executed in the initial
   state of the pretty-printer.
<p>

   Warning: the material output by the following functions is delayed
   in the pretty-printer queue in order to compute the proper line
   breaking. Hence, you should not mix calls to the printing functions
   of the basic I/O system with calls to the functions of this module:
   this could result in some strange output seemingly unrelated with
   the evaluation order of printing commands.<br>
<hr width="100%">
<br>
<a name="6_Boxes"></a>
<h6>Boxes</h6><br>
<pre><span class="keyword">val</span> <a name="VALopen_box"></a>open_box : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">open_box d</code> opens a new pretty-printing box
   with offset <code class="code">d</code>.
   This box is the general purpose pretty-printing box.
   Material in this box is displayed ``horizontal or vertical'':
   break hints inside the box may lead to a new line, if there
   is no more room on the line to print the remainder of the box,
   or if a new line may lead to a new indentation
   (demonstrating the indentation of the box).
   When a new line is printed in the box, <code class="code">d</code> is added to the
   current indentation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclose_box"></a>close_box : <code class="type">unit -> unit</code></pre><div class="info">
Closes the most recently opened pretty-printing box.<br>
</div>
<br>
<a name="6_Formattingfunctions"></a>
<h6>Formatting functions</h6><br>
<pre><span class="keyword">val</span> <a name="VALprint_string"></a>print_string : <code class="type">string -> unit</code></pre><div class="info">
<code class="code">print_string str</code> prints <code class="code">str</code> in the current box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_as"></a>print_as : <code class="type">int -> string -> unit</code></pre><div class="info">
<code class="code">print_as len str</code> prints <code class="code">str</code> in the
   current box. The pretty-printer formats <code class="code">str</code> as if
   it were of length <code class="code">len</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_int"></a>print_int : <code class="type">int -> unit</code></pre><div class="info">
Prints an integer in the current box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_float"></a>print_float : <code class="type">float -> unit</code></pre><div class="info">
Prints a floating point number in the current box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_char"></a>print_char : <code class="type">char -> unit</code></pre><div class="info">
Prints a character in the current box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_bool"></a>print_bool : <code class="type">bool -> unit</code></pre><div class="info">
Prints a boolean in the current box.<br>
</div>
<br>
<a name="6_Breakhints"></a>
<h6>Break hints</h6><br>
<pre><span class="keyword">val</span> <a name="VALprint_space"></a>print_space : <code class="type">unit -> unit</code></pre><div class="info">
<code class="code">print_space ()</code> is used to separate items (typically to print
   a space between two words).
   It indicates that the line may be split at this
   point. It either prints one space or splits the line.
   It is equivalent to <code class="code">print_break 1 0</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_cut"></a>print_cut : <code class="type">unit -> unit</code></pre><div class="info">
<code class="code">print_cut ()</code> is used to mark a good break position.
   It indicates that the line may be split at this
   point. It either prints nothing or splits the line.
   This allows line splitting at the current
   point, without printing spaces or adding indentation.
   It is equivalent to <code class="code">print_break 0 0</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_break"></a>print_break : <code class="type">int -> int -> unit</code></pre><div class="info">
Inserts a break hint in a pretty-printing box.
   <code class="code">print_break nspaces offset</code> indicates that the line may
   be split (a newline character is printed) at this point,
   if the contents of the current box does not fit on the
   current line.
   If the line is split at that point, <code class="code">offset</code> is added to
   the current indentation. If the line is not split,
   <code class="code">nspaces</code> spaces are printed.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_flush"></a>print_flush : <code class="type">unit -> unit</code></pre><div class="info">
Flushes the pretty printer: all opened boxes are closed,
   and all pending text is displayed.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_newline"></a>print_newline : <code class="type">unit -> unit</code></pre><div class="info">
Equivalent to <code class="code">print_flush</code> followed by a new line.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALforce_newline"></a>force_newline : <code class="type">unit -> unit</code></pre><div class="info">
Forces a newline in the current box. Not the normal way of
   pretty-printing, you should prefer break hints.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_if_newline"></a>print_if_newline : <code class="type">unit -> unit</code></pre><div class="info">
Executes the next formatting command if the preceding line
   has just been split. Otherwise, ignore the next formatting
   command.<br>
</div>
<br>
<a name="6_Margin"></a>
<h6>Margin</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_margin"></a>set_margin : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">set_margin d</code> sets the value of the right margin
   to <code class="code">d</code> (in characters): this value is used to detect line
   overflows that leads to split lines.
   Nothing happens if <code class="code">d</code> is smaller than 2.
   If <code class="code">d</code> is too large, the right margin is set to the maximum
   admissible value (which is greater than <code class="code">10^10</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_margin"></a>get_margin : <code class="type">unit -> int</code></pre><div class="info">
Returns the position of the right margin.<br>
</div>
<br>
<a name="6_Maximumindentationlimit"></a>
<h6>Maximum indentation limit</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_max_indent"></a>set_max_indent : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">set_max_indent d</code> sets the value of the maximum
   indentation limit to <code class="code">d</code> (in characters):
   once this limit is reached, boxes are rejected to the left,
   if they do not fit on the current line.
   Nothing happens if <code class="code">d</code> is smaller than 2.
   If <code class="code">d</code> is too large, the limit is set to the maximum
   admissible value (which is greater than <code class="code">10^10</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_max_indent"></a>get_max_indent : <code class="type">unit -> int</code></pre><div class="info">
Return the value of the maximum indentation limit (in characters).<br>
</div>
<br>
<a name="6_Formattingdepthmaximumnumberofboxesallowedbeforeellipsis"></a>
<h6>Formatting depth: maximum number of boxes allowed before ellipsis</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_max_boxes"></a>set_max_boxes : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">set_max_boxes max</code> sets the maximum number
   of boxes simultaneously opened.
   Material inside boxes nested deeper is printed as an
   ellipsis (more precisely as the text returned by
   <code class="code">get_ellipsis_text ()</code>).
   Nothing happens if <code class="code">max</code> is smaller than 2.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_max_boxes"></a>get_max_boxes : <code class="type">unit -> int</code></pre><div class="info">
Returns the maximum number of boxes allowed before ellipsis.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALover_max_boxes"></a>over_max_boxes : <code class="type">unit -> bool</code></pre><div class="info">
Tests if the maximum number of boxes allowed have already been opened.<br>
</div>
<br>
<a name="6_Advancedformatting"></a>
<h6>Advanced formatting</h6><br>
<pre><span class="keyword">val</span> <a name="VALopen_hbox"></a>open_hbox : <code class="type">unit -> unit</code></pre><div class="info">
<code class="code">open_hbox ()</code> opens a new pretty-printing box.
   This box is ``horizontal'': the line is not split in this box
   (new lines may still occur inside boxes nested deeper).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_vbox"></a>open_vbox : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">open_vbox d</code> opens a new pretty-printing box
   with offset <code class="code">d</code>.
   This box is ``vertical'': every break hint inside this
   box leads to a new line.
   When a new line is printed in the box, <code class="code">d</code> is added to the
   current indentation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_hvbox"></a>open_hvbox : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">open_hvbox d</code> opens a new pretty-printing box
   with offset <code class="code">d</code>.
   This box is ``horizontal-vertical'': it behaves as an
   ``horizontal'' box if it fits on a single line,
   otherwise it behaves as a ``vertical'' box.
   When a new line is printed in the box, <code class="code">d</code> is added to the
   current indentation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_hovbox"></a>open_hovbox : <code class="type">int -> unit</code></pre><div class="info">
<code class="code">open_hovbox d</code> opens a new pretty-printing box
   with offset <code class="code">d</code>.
   This box is ``horizontal or vertical'': break hints
   inside this box may lead to a new line, if there is no more room
   on the line to print the remainder of the box.
   When a new line is printed in the box, <code class="code">d</code> is added to the
   current indentation.<br>
</div>
<br>
<a name="6_Tabulations"></a>
<h6>Tabulations</h6><br>
<pre><span class="keyword">val</span> <a name="VALopen_tbox"></a>open_tbox : <code class="type">unit -> unit</code></pre><div class="info">
Opens a tabulation box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclose_tbox"></a>close_tbox : <code class="type">unit -> unit</code></pre><div class="info">
Closes the most recently opened tabulation box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_tbreak"></a>print_tbreak : <code class="type">int -> int -> unit</code></pre><div class="info">
Break hint in a tabulation box.
   <code class="code">print_tbreak spaces offset</code> moves the insertion point to
   the next tabulation (<code class="code">spaces</code> being added to this position).
   Nothing occurs if insertion point is already on a
   tabulation mark.
   If there is no next tabulation on the line, then a newline
   is printed and the insertion point moves to the first
   tabulation of the box.
   If a new line is printed, <code class="code">offset</code> is added to the current
   indentation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_tab"></a>set_tab : <code class="type">unit -> unit</code></pre><div class="info">
Sets a tabulation mark at the current insertion point.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprint_tab"></a>print_tab : <code class="type">unit -> unit</code></pre><div class="info">
<code class="code">print_tab ()</code> is equivalent to <code class="code">print_tbreak (0,0)</code>.<br>
</div>
<br>
<a name="6_Ellipsis"></a>
<h6>Ellipsis</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_ellipsis_text"></a>set_ellipsis_text : <code class="type">string -> unit</code></pre><div class="info">
Set the text of the ellipsis printed when too many boxes
   are opened (a single dot, <code class="code">.</code>, by default).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_ellipsis_text"></a>get_ellipsis_text : <code class="type">unit -> string</code></pre><div class="info">
Return the text of the ellipsis.<br>
</div>
<br>
<a name="6_Tags"></a>
<h6>Tags</h6><br>
<pre><span class="keyword">type</span> <a name="TYPEtag"></a><code class="type"></code>tag = <code class="type">string</code> </pre>

<br>
Tags are used to decorate printed entities for user's defined
   purposes, e.g. setting font and giving size indications for a
   display device, or marking delimitations of semantics entities
   (e.g. HTML or TeX elements or terminal escape sequences).
<p>

   By default, those tags do not influence line breaking calculation:
   the tag ``markers'' are not considered as part of the printing
   material that drives line breaking (in other words, the length of
   those strings is considered as zero for line breaking).
<p>

   Thus, tag handling is in some sense transparent to pretty-printing
   and does not interfere with usual pretty-printing. Hence, a single
   pretty printing routine can output both simple ``verbatim''
   material or richer decorated output depending on the treatment of
   tags. By default, tags are not active, hence the output is not
   decorated with tag information.  Once <code class="code">set_tags</code> is set to <code class="code"><span class="keyword">true</span></code>,
   the pretty printer engine honors tags and decorates the output
   accordingly.
<p>

   When a tag has been opened (or closed), it is both and successively
   ``printed'' and ``marked''. Printing a tag means calling a
   formatter specific function with the name of the tag as argument:
   that ``tag printing'' function can then print any regular material
   to the formatter (so that this material is enqueued as usual in the
   formatter queue for further line-breaking computation). Marking a
   tag means to output an arbitrary string (the ``tag marker''),
   directly into the output device of the formatter. Hence, the
   formatter specific ``tag marking'' function must return the tag
   marker string associated to its tag argument. Being flushed
   directly into the output device of the formatter, tag marker
   strings are not considered as part of the printing material that
   drives line breaking (in other words, the length of the strings
   corresponding to tag markers is considered as zero for line
   breaking). In addition, advanced users may take advantage of
   the specificity of tag markers to be precisely output when the
   pretty printer has already decided where to break the lines, and
   precisely when the queue is flushed into the output device.
<p>

   In the spirit of HTML tags, the default tag marking functions
   output tags enclosed in "&lt;" and "&gt;": hence, the opening marker of
   tag <code class="code">t</code> is <code class="code"><span class="string">"&lt;t&gt;"</span></code> and the closing marker <code class="code"><span class="string">"&lt;/t&gt;"</span></code>.
<p>

   Default tag printing functions just do nothing.
<p>

   Tag marking and tag printing functions are user definable and can
   be set by calling <code class="code">set_formatter_tag_functions</code>.<br>
<pre><span class="keyword">val</span> <a name="VALopen_tag"></a>open_tag : <code class="type"><a href="Format.html#TYPEtag">tag</a> -> unit</code></pre><div class="info">
<code class="code">open_tag t</code> opens the tag named <code class="code">t</code>; the <code class="code">print_open_tag</code>
   function of the formatter is called with <code class="code">t</code> as argument;
   the tag marker <code class="code">mark_open_tag t</code> will be flushed into the output
   device of the formatter.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclose_tag"></a>close_tag : <code class="type">unit -> unit</code></pre><div class="info">
<code class="code">close_tag ()</code> closes the most recently opened tag <code class="code">t</code>.
   In addition, the <code class="code">print_close_tag</code> function of the formatter is called
   with <code class="code">t</code> as argument. The marker <code class="code">mark_close_tag t</code> will be flushed
   into the output device of the formatter.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_tags"></a>set_tags : <code class="type">bool -> unit</code></pre><div class="info">
<code class="code">set_tags b</code> turns on or off the treatment of tags (default is off).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_print_tags"></a>set_print_tags : <code class="type">bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_mark_tags"></a>set_mark_tags : <code class="type">bool -> unit</code></pre><div class="info">
<code class="code">set_print_tags b</code> turns on or off the printing of tags, while
    <code class="code">set_mark_tags b</code> turns on or off the output of tag markers.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_print_tags"></a>get_print_tags : <code class="type">unit -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALget_mark_tags"></a>get_mark_tags : <code class="type">unit -> bool</code></pre><div class="info">
Return the current status of tags printing and tags marking.<br>
</div>
<br>
<a name="6_Redirectingformatteroutput"></a>
<h6>Redirecting formatter output</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_formatter_out_channel"></a>set_formatter_out_channel : <code class="type"><a href="Pervasives.html#TYPEout_channel">out_channel</a> -> unit</code></pre><div class="info">
Redirect the pretty-printer output to the given channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_formatter_output_functions"></a>set_formatter_output_functions : <code class="type">(string -> int -> int -> unit) -> (unit -> unit) -> unit</code></pre><div class="info">
<code class="code">set_formatter_output_functions out flush</code> redirects the
   pretty-printer output to the functions <code class="code">out</code> and <code class="code">flush</code>.
<p>

   The <code class="code">out</code> function performs the pretty-printer output. It is called
   with a string <code class="code">s</code>, a start position <code class="code">p</code>, and a number of characters
   <code class="code">n</code>; it is supposed to output characters <code class="code">p</code> to <code class="code">p + n - 1</code> of
   <code class="code">s</code>. The <code class="code">flush</code> function is called whenever the pretty-printer is
   flushed using <code class="code">print_flush</code> or <code class="code">print_newline</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_formatter_output_functions"></a>get_formatter_output_functions : <code class="type">unit -> (string -> int -> int -> unit) * (unit -> unit)</code></pre><div class="info">
Return the current output functions of the pretty-printer.<br>
</div>
<br>
<a name="6_Changingthemeaningofprintingtags"></a>
<h6>Changing the meaning of printing tags</h6><br>
<br><code><span class="keyword">type</span> <a name="TYPEformatter_tag_functions"></a><code class="type"></code>formatter_tag_functions = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>mark_open_tag&nbsp;: <code class="type"><a href="Format.html#TYPEtag">tag</a> -> string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>mark_close_tag&nbsp;: <code class="type"><a href="Format.html#TYPEtag">tag</a> -> string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>print_open_tag&nbsp;: <code class="type"><a href="Format.html#TYPEtag">tag</a> -> unit</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>print_close_tag&nbsp;: <code class="type"><a href="Format.html#TYPEtag">tag</a> -> unit</code>;</code></td>

</tr></table>
}

<div class="info">
The tag handling functions specific to a formatter:
   <code class="code">mark</code> versions are the ``tag marking'' functions that associate a string
   marker to a tag in order for the pretty-printing engine to flush
   those markers as 0 length tokens in the output device of the formatter.
   <code class="code">print</code> versions are the ``tag printing'' functions that can perform
   regular printing when a tag is closed or opened.<br>
</div>

<pre><span class="keyword">val</span> <a name="VALset_formatter_tag_functions"></a>set_formatter_tag_functions : <code class="type"><a href="Format.html#TYPEformatter_tag_functions">formatter_tag_functions</a> -> unit</code></pre><br>
<code class="code">set_formatter_tag_functions tag_funs</code> changes the meaning of
   opening and closing tags to use the functions in <code class="code">tag_funs</code>.
<p>

   When opening a tag name <code class="code">t</code>, the string <code class="code">t</code> is passed to the
   opening tag marking function (the <code class="code">mark_open_tag</code> field of the
   record <code class="code">tag_funs</code>), that must return the opening tag marker for
   that name. When the next call to <code class="code">close_tag ()</code> happens, the tag
   name <code class="code">t</code> is sent back to the closing tag marking function (the
   <code class="code">mark_close_tag</code> field of record <code class="code">tag_funs</code>), that must return a
   closing tag marker for that name.
<p>

   The <code class="code">print_</code> field of the record contains the functions that are
   called at tag opening and tag closing time, to output regular
   material in the pretty-printer queue.<br>
<pre><span class="keyword">val</span> <a name="VALget_formatter_tag_functions"></a>get_formatter_tag_functions : <code class="type">unit -> <a href="Format.html#TYPEformatter_tag_functions">formatter_tag_functions</a></code></pre><div class="info">
Return the current tag functions of the pretty-printer.<br>
</div>
<br>
<a name="6_Changingthemeaningofprettyprintingindentationlinebreakingandprintingmaterial"></a>
<h6>Changing the meaning of pretty printing (indentation, line breaking,
 and printing material)</h6><br>
<pre><span class="keyword">val</span> <a name="VALset_all_formatter_output_functions"></a>set_all_formatter_output_functions : <code class="type">out:(string -> int -> int -> unit) -><br>       flush:(unit -> unit) -><br>       newline:(unit -> unit) -> spaces:(int -> unit) -> unit</code></pre><div class="info">
<code class="code">set_all_formatter_output_functions out flush outnewline outspace</code>
   redirects the pretty-printer output to the functions <code class="code">out</code> and
   <code class="code">flush</code> as described in <code class="code">set_formatter_output_functions</code>. In
   addition, the pretty-printer function that outputs a newline is set
   to the function <code class="code">outnewline</code> and the function that outputs
   indentation spaces is set to the function <code class="code">outspace</code>.
<p>

   This way, you can change the meaning of indentation (which can be
   something else than just printing space characters) and the
   meaning of new lines opening (which can be connected to any other
   action needed by the application at hand). The two functions
   <code class="code">outspace</code> and <code class="code">outnewline</code> are normally connected to <code class="code">out</code> and
   <code class="code">flush</code>: respective default values for <code class="code">outspace</code> and <code class="code">outnewline</code>
   are <code class="code">out (<span class="constructor">String</span>.make n <span class="string">' '</span>) 0 n</code> and <code class="code">out <span class="string">"\n"</span> 0 1</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_all_formatter_output_functions"></a>get_all_formatter_output_functions : <code class="type">unit -><br>       (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *<br>       (int -> unit)</code></pre><div class="info">
Return the current output functions of the pretty-printer,
   including line breaking and indentation functions.<br>
</div>
<br>
<a name="6_Multipleformattedoutput"></a>
<h6>Multiple formatted output</h6><br>
<pre><span class="keyword">type</span> <a name="TYPEformatter"></a><code class="type"></code>formatter </pre>
<div class="info">
Abstract data type corresponding to a pretty-printer (also called a
   formatter) and all its machinery.
   Defining new pretty-printers permits the output of
   material in parallel on several channels.
   Parameters of a pretty-printer are local to this pretty-printer:
   margin, maximum indentation limit, maximum number of boxes
   simultaneously opened, ellipsis, and so on, are specific to
   each pretty-printer and may be fixed independently.
   Given an output channel <code class="code">oc</code>, a new formatter writing to
   that channel is obtained by calling <code class="code">formatter_of_out_channel oc</code>.
   Alternatively, the <code class="code">make_formatter</code> function allocates a new
   formatter with explicit output and flushing functions
   (convenient to output material to strings for instance).<br>
</div>

<pre><span class="keyword">val</span> <a name="VALformatter_of_out_channel"></a>formatter_of_out_channel : <code class="type"><a href="Pervasives.html#TYPEout_channel">out_channel</a> -> <a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
<code class="code">formatter_of_out_channel oc</code> returns a new formatter that
   writes to the corresponding channel <code class="code">oc</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstd_formatter"></a>std_formatter : <code class="type"><a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
The standard formatter used by the formatting functions
   above. It is defined as <code class="code">formatter_of_out_channel stdout</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALerr_formatter"></a>err_formatter : <code class="type"><a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
A formatter to use with formatting functions below for
   output to standard error. It is defined as
   <code class="code">formatter_of_out_channel stderr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALformatter_of_buffer"></a>formatter_of_buffer : <code class="type"><a href="Buffer.html#TYPEt">Buffer.t</a> -> <a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
<code class="code">formatter_of_buffer b</code> returns a new formatter writing to
   buffer <code class="code">b</code>. As usual, the formatter has to be flushed at
   the end of pretty printing, using <code class="code">pp_print_flush</code> or
   <code class="code">pp_print_newline</code>, to display all the pending material.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstdbuf"></a>stdbuf : <code class="type"><a href="Buffer.html#TYPEt">Buffer.t</a></code></pre><div class="info">
The string buffer in which <code class="code">str_formatter</code> writes.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstr_formatter"></a>str_formatter : <code class="type"><a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
A formatter to use with formatting functions below for
   output to the <code class="code">stdbuf</code> string buffer.
   <code class="code">str_formatter</code> is defined as <code class="code">formatter_of_buffer stdbuf</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALflush_str_formatter"></a>flush_str_formatter : <code class="type">unit -> string</code></pre><div class="info">
Returns the material printed with <code class="code">str_formatter</code>, flushes
   the formatter and resets the corresponding buffer.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake_formatter"></a>make_formatter : <code class="type">(string -> int -> int -> unit) -> (unit -> unit) -> <a href="Format.html#TYPEformatter">formatter</a></code></pre><div class="info">
<code class="code">make_formatter out flush</code> returns a new formatter that
   writes according to the output function <code class="code">out</code>, and the flushing
   function <code class="code">flush</code>. Hence, a formatter to the out channel <code class="code">oc</code>
   is returned by <code class="code">make_formatter (output oc) (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> flush oc)</code>.<br>
</div>
<br>
<a name="6_Basicfunctionstousewithformatters"></a>
<h6>Basic functions to use with formatters</h6><br>
<pre><span class="keyword">val</span> <a name="VALpp_open_hbox"></a>pp_open_hbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_vbox"></a>pp_open_vbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_hvbox"></a>pp_open_hvbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_hovbox"></a>pp_open_hovbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_box"></a>pp_open_box : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_close_box"></a>pp_close_box : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_tag"></a>pp_open_tag : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_close_tag"></a>pp_close_tag : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_string"></a>pp_print_string : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_as"></a>pp_print_as : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_int"></a>pp_print_int : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_float"></a>pp_print_float : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> float -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_char"></a>pp_print_char : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> char -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_bool"></a>pp_print_bool : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_break"></a>pp_print_break : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_cut"></a>pp_print_cut : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_space"></a>pp_print_space : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_force_newline"></a>pp_force_newline : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_flush"></a>pp_print_flush : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_newline"></a>pp_print_newline : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_if_newline"></a>pp_print_if_newline : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_open_tbox"></a>pp_open_tbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_close_tbox"></a>pp_close_tbox : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_tbreak"></a>pp_print_tbreak : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_tab"></a>pp_set_tab : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_print_tab"></a>pp_print_tab : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_tags"></a>pp_set_tags : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_print_tags"></a>pp_set_print_tags : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_mark_tags"></a>pp_set_mark_tags : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_print_tags"></a>pp_get_print_tags : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_mark_tags"></a>pp_get_mark_tags : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_margin"></a>pp_set_margin : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_margin"></a>pp_get_margin : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_max_indent"></a>pp_set_max_indent : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_max_indent"></a>pp_get_max_indent : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_max_boxes"></a>pp_set_max_boxes : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_max_boxes"></a>pp_get_max_boxes : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALpp_over_max_boxes"></a>pp_over_max_boxes : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_ellipsis_text"></a>pp_set_ellipsis_text : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_ellipsis_text"></a>pp_get_ellipsis_text : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> string</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_formatter_out_channel"></a>pp_set_formatter_out_channel : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> <a href="Pervasives.html#TYPEout_channel">out_channel</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_formatter_output_functions"></a>pp_set_formatter_output_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> (string -> int -> int -> unit) -> (unit -> unit) -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_formatter_output_functions"></a>pp_get_formatter_output_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> (string -> int -> int -> unit) * (unit -> unit)</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_all_formatter_output_functions"></a>pp_set_all_formatter_output_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -><br>       out:(string -> int -> int -> unit) -><br>       flush:(unit -> unit) -><br>       newline:(unit -> unit) -> spaces:(int -> unit) -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_all_formatter_output_functions"></a>pp_get_all_formatter_output_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -><br>       unit -><br>       (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *<br>       (int -> unit)</code></pre><pre><span class="keyword">val</span> <a name="VALpp_set_formatter_tag_functions"></a>pp_set_formatter_tag_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> <a href="Format.html#TYPEformatter_tag_functions">formatter_tag_functions</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpp_get_formatter_tag_functions"></a>pp_get_formatter_tag_functions : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> unit -> <a href="Format.html#TYPEformatter_tag_functions">formatter_tag_functions</a></code></pre><div class="info">
These functions are the basic ones: usual functions
   operating on the standard formatter are defined via partial
   evaluation of these primitives. For instance,
   <code class="code">print_string</code> is equal to <code class="code">pp_print_string std_formatter</code>.<br>
</div>
<br>
<a name="6_printflikefunctionsforprettyprinting"></a>
<h6><code class="code">printf</code> like functions for pretty-printing.</h6><br>
<pre><span class="keyword">val</span> <a name="VALfprintf"></a>fprintf : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> ('a, <a href="Format.html#TYPEformatter">formatter</a>, unit) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
<code class="code">fprintf ff format arg1 ... argN</code> formats the arguments
   <code class="code">arg1</code> to <code class="code">argN</code> according to the format string <code class="code">format</code>,
   and outputs the resulting string on the formatter <code class="code">ff</code>.
   The format is a character string which contains three types of
   objects: plain characters and conversion specifications as
   specified in the <code class="code">printf</code> module, and pretty-printing
   indications.
   The pretty-printing indication characters are introduced by
   a <code class="code">@</code> character, and their meanings are:<ul>
<li><code class="code">@[</code>: open a pretty-printing box. The type and offset of the
     box may be optionally specified with the following syntax:
     the <code class="code">&lt;</code> character, followed by an optional box type indication,
     then an optional integer offset, and the closing <code class="code">&gt;</code> character.
     Box type is one of <code class="code">h</code>, <code class="code">v</code>, <code class="code">hv</code>, <code class="code">b</code>, or <code class="code">hov</code>,
     which stand respectively for an horizontal box, a vertical box,
     an ``horizontal-vertical'' box, or an ``horizontal or
     vertical'' box (<code class="code">b</code> standing for an ``horizontal or
     vertical'' box demonstrating indentation and <code class="code">hov</code> standing
     for a regular``horizontal or vertical'' box).
     For instance, <code class="code">@[&lt;hov 2&gt;</code> opens an ``horizontal or vertical''
     box with indentation 2 as obtained with <code class="code">open_hovbox 2</code>.
     For more details about boxes, see the various box opening
     functions <code class="code">open_*box</code>.</li>
<li><code class="code">@]</code>: close the most recently opened pretty-printing box.</li>
<li><code class="code">@,</code>: output a good break as with <code class="code">print_cut ()</code>.</li>
<li><code class="code">@ </code>: output a space, as with <code class="code">print_space ()</code>.</li>
<li><code class="code">@\n</code>: force a newline, as with <code class="code">force_newline ()</code>.</li>
<li><code class="code">@;</code>: output a good break as with <code class="code">print_break</code>. The
     <code class="code">nspaces</code> and <code class="code">offset</code> parameters of the break may be
     optionally specified with the following syntax:
     the <code class="code">&lt;</code> character, followed by an integer <code class="code">nspaces</code> value,
     then an integer <code class="code">offset</code>, and a closing <code class="code">&gt;</code> character.
     If no parameters are provided, the good break defaults to a
     space.</li>
<li><code class="code">@?</code>: flush the pretty printer as with <code class="code">print_flush ()</code>.
     This is equivalent to the conversion <code class="code">%!</code>.</li>
<li><code class="code">@.</code>: flush the pretty printer and output a new line, as with
     <code class="code">print_newline ()</code>.</li>
<li><code class="code">@&lt;n&gt;</code>: print the following item as if it were of length <code class="code">n</code>.
     Hence, <code class="code">printf <span class="string">"@&lt;0&gt;%s"</span> arg</code> is equivalent to <code class="code">print_as 0 arg</code>.
     If <code class="code">@&lt;n&gt;</code> is not followed by a conversion specification,
     then the following character of the format is printed as if
     it were of length <code class="code">n</code>.</li>
<li><code class="code">@{</code>: open a tag. The name of the tag may be optionally
     specified with the following syntax:
     the <code class="code">&lt;</code> character, followed by an optional string
     specification, and the closing <code class="code">&gt;</code> character. The string
     specification is any character string that does not contain the
     closing character <code class="code"><span class="string">'&gt;'</span></code>. If omitted, the tag name defaults to the
     empty string.
     For more details about tags, see the functions <code class="code">open_tag</code> and
     <code class="code">close_tag</code>.</li>
<li><code class="code">@}</code>: close the most recently opened tag.</li>
<li><code class="code">@@</code>: print a plain <code class="code">@</code> character.</li>
</ul>

   Example: <code class="code">printf <span class="string">"@[%s@ %d@]"</span> <span class="string">"x ="</span> 1</code> is equivalent to
   <code class="code">open_box (); print_string <span class="string">"x ="</span>; print_space (); print_int 1; close_box ()</code>.
   It prints <code class="code">x = 1</code> within a pretty-printing box.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALprintf"></a>printf : <code class="type">('a, <a href="Format.html#TYPEformatter">formatter</a>, unit) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
Same as <code class="code">fprintf</code> above, but output on <code class="code">std_formatter</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALeprintf"></a>eprintf : <code class="type">('a, <a href="Format.html#TYPEformatter">formatter</a>, unit) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
Same as <code class="code">fprintf</code> above, but output on <code class="code">err_formatter</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsprintf"></a>sprintf : <code class="type">('a, unit, string) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
Same as <code class="code">printf</code> above, but instead of printing on a formatter,
   returns a string containing the result of formatting the arguments.
   Note that the pretty-printer queue is flushed at the end of each
   call to <code class="code">sprintf</code>.
<p>

   In case of multiple and related calls to <code class="code">sprintf</code> to output
   material on a single string, you should consider using <code class="code">fprintf</code>
   with a formatter writing to a buffer: flushing the buffer at the
   end of pretty-printing returns the desired string. You can also use
   the predefined formatter <code class="code">str_formatter</code> and call
   <code class="code">flush_str_formatter ()</code> to get the result.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbprintf"></a>bprintf : <code class="type"><a href="Buffer.html#TYPEt">Buffer.t</a> -> ('a, <a href="Format.html#TYPEformatter">formatter</a>, unit) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
Same as <code class="code">sprintf</code> above, but instead of printing on a string,
   writes into the given extensible buffer.
   As for <code class="code">sprintf</code>, the pretty-printer queue is flushed at the end of each
   call to <code class="code">bprintf</code>.
<p>

   In case of multiple and related calls to <code class="code">bprintf</code> to output
   material on the same buffer <code class="code">b</code>, you should consider using
   <code class="code">fprintf</code> with a formatter writing to the buffer <code class="code">b</code> (as obtained
   by <code class="code">formatter_of_buffer b</code>), otherwise the repeated flushes of the
   pretty-printer queue would result in unexpected and badly formatted
   output.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkfprintf"></a>kfprintf : <code class="type">(<a href="Format.html#TYPEformatter">formatter</a> -> 'a) -><br>       <a href="Format.html#TYPEformatter">formatter</a> -> ('b, <a href="Format.html#TYPEformatter">formatter</a>, unit, 'a) <a href="Pervasives.html#TYPEformat4">format4</a> -> 'b</code></pre><div class="info">
Same as <code class="code">fprintf</code> above, but instead of returning immediately,
   passes the formatter to its first argument at the end of printing.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALifprintf"></a>ifprintf : <code class="type"><a href="Format.html#TYPEformatter">formatter</a> -> ('a, <a href="Format.html#TYPEformatter">formatter</a>, unit) <a href="Pervasives.html#TYPEformat">format</a> -> 'a</code></pre><div class="info">
Same as <code class="code">fprintf</code> above, but does not print anything.
   Useful to ignore some material when conditionally printing.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALksprintf"></a>ksprintf : <code class="type">(string -> 'a) -> ('b, unit, string, 'a) <a href="Pervasives.html#TYPEformat4">format4</a> -> 'b</code></pre><div class="info">
Same as <code class="code">sprintf</code> above, but instead of returning the string,
   passes it to the first argument.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALkprintf"></a>kprintf : <code class="type">(string -> 'a) -> ('b, unit, string, 'a) <a href="Pervasives.html#TYPEformat4">format4</a> -> 'b</code></pre><div class="info">
A deprecated synonym for <code class="code">ksprintf</code>.<br>
</div>
</body></html>